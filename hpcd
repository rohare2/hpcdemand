#!/usr/bin/perl
# $Id: $
# $Date: $
# hpcd
#
# High Performance Computer Demand Client
#
use strict;
use warnings;
use IO::Socket::INET;
use Date::Manip qw(ParseDate UnixDate);
use Getopt::Std;

# auto-flush on socket
$| = 1;

# set to 1 for debug mode
my $debug = 0;

# Identify user
my $username = getpwuid ($<);

# Command line arguments
our ($opt_a, $opt_c, $opt_d, $opt_f, $opt_h, $opt_l, $opt_t, $opt_u);
my $from_date = 0;
my $to_date = 99999999;

getopts("ac:d:fhltu:");
$opt_h && &usage();
$opt_l && ($opt_a || $opt_c || $opt_d || $opt_u) && &usage;
$opt_d && ($opt_a || $opt_c || $opt_u) && &usage;
$opt_u && ($opt_a || $opt_c ) && &usage;

sub usage() {
	print "Client for reporting anticipated HPC load\n";
	print "Usage: hpcd [-l|-u <userid>] [-ft] \n";
	print "       hpcd -a\n";
	print "       hpcd -c\n";
	print "       hpcd -d <itemNo>\n";
	print "       hpcd -h\n";
	print "\n";
	print "       -a  Add a node reservation\n";
	print "       -c  Copy a node reservation\n";
	print "       -d  Delete a node reservation by item number\n";
	print "       -f  Display reservation records starting from date\n";
	print "          User will be prompted for date\n";
	print "       -h  Print this help messages\n";
	print "       -l  Long listing, show all users\n";
	print "       -t  Display reservation records ending at this date\n";
	print "          User will be prompted for date\n";
	print "       -u  Include only the specified user\n";
	print "\n";
	print "       Dates can be entered as MM/DD/YY, YYYY/MM/DD, tomorrow\n";
	print "       next month, etc...  Experiment.\n";
	exit;
}

# who's records to list
my $user = $username;
if ( $opt_l ) {
	$user = 'ALL';
} elsif ( $opt_u ) {
	$user = $opt_u;
}

# create a connecting socket
my $socket = new IO::Socket::INET (
	PeerHost => '0.0.0.0',
	PeerPort => '7777',
	Proto => 'tcp',
);
die "cannot connect to the server $!\n" unless $socket;
$debug && print "connected to the server\n";

if ( $opt_f ) { # Request from date
	$from_date = &getFromDate();
}

if ( $opt_t ) { # Request to date
	$to_date = &getToDate();
}

if ( $opt_a ) {
	# Add record
	&addRecord();
} elsif ( $opt_c ) {
	# Copy record
	&copyRecord();
} elsif ( $opt_d ) {
	# Delete record
	&deleteRecord();
} else {
	# List records (default)
	&listRecords();
}

my $req;

sub addRecord() {
	print "Start Date? ";
	my $x = time() - 24*60*60;
	my $start;
	while (<STDIN>) {
		 my $date = ParseDate($_);
		print "ooops - don't understand!\n" if not $date;
		next if not $date;
		my ($y,$m,$d)=UnixDate($date, "%Y", "%m", "%d");
		my ($e)=UnixDate($date, "%s");
		if ($e < $x) {
			print "Can't accept $m/$d/$y start date must be in the future\n";
			next;
		}
		$start = sprintf("%04d%02d%02d", $y,$m,$d);
		last;
	}
	print "End Date? ";
	my $end;
	while (<STDIN>) {
		my $date = ParseDate($_);
		print "ooops - don't understand!\n" if not $date;
		next if not $date;
		my ($y,$m,$d)=UnixDate($date, "%Y", "%m", "%d");
		my ($e)=UnixDate($date, "%s");
		if ($e < $x) {
			print "Can't accept $m/$d/$y end date must be in the future\n";
			next;
		}
		$end = sprintf("%04d%02d%02d", $y,$m,$d);
		last;
	}
	print "Nodes required [4]: ";
	chomp (my $nodes = <STDIN>);
	$nodes = 4 if $nodes eq '';
	print "Work desctiption: ";
	chomp (my $desc = <STDIN>);

	# data to send to server
	$req = "mode:add;user:$username;start:$start;end:$end;nodes:$nodes;desc:$desc";
}

sub listRecords() {
	$req = "mode:list;user:$user;from:$from_date;to:$to_date";
}

sub deleteRecord() {
	if ( $opt_d gt 0 ) {
		$req = "mode:delete;itemNo:$opt_d";
	} else {
		print "Invalid itemNo: $opt_d\n";
		exit;
	}
}

sub copyRecord() {
	if ( $opt_c gt 0 ) {
		$req = "mode:copy;itemNo:$opt_c";
	} else {
		print "Invalid itemNo: $opt_c\n";
		exit;
	}
}

sub getFromDate() {
	print "From date? ";
	my $x = time();
	my $from_date;
	while (<STDIN>) {
		my $date = ParseDate($_);
		print "ooops - don't understand!\n" if not $date;
		next if not $date;
		my ($y,$m,$d)=UnixDate($date, "%Y", "%m", "%d");
		my ($e)=UnixDate($date, "%s");
		if ($e < $x) {
			print "Can't accept $m/$d/$y start date must be in the future\n";
			next;
		}
		$from_date = sprintf("%04d%02d%02d", $y,$m,$d);
		last;
	}
	return $from_date;
}

sub getToDate() {
	print "To date? ";
	my $x = time();
	my $to_date;
	while (<STDIN>) {
		my $date = ParseDate($_);
		print "ooops - don't understand!\n" if not $date;
		next if not $date;
		my ($y,$m,$d)=UnixDate($date, "%Y", "%m", "%d");
		my ($e)=UnixDate($date, "%s");
		if ($e < $x) {
			print "Can't accept $m/$d/$y end date must be in the future\n";
			next;
		}
		$to_date = sprintf("%04d%02d%02d", $y,$m,$d);
		last;
	}
	return $to_date;
}

# send data to server
$socket->send($req);

# notify server that request has been sent
shutdown($socket, 1);

# receive a response of up to 1024 characters from server
while(my $response = <$socket>) {
	#$socket->recv($response, 1024);
	last if $response eq "END_OF_REQUEST";
	print "$response";
}

$socket->close();

